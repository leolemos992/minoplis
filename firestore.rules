/**
 * @fileoverview Firestore Security Rules for Localopoly.
 *
 * Core Philosophy:
 * This ruleset prioritizes strong authorization based on user identity and game ownership.
 * It assumes a collaborative environment where players interact within the context of a game.
 * Data validation is relaxed to facilitate rapid prototyping.
 *
 * Data Structure:
 * - /games/{gameId}: Root collection for games.
 *   - /players/{playerId}: Subcollection for players within a game.
 *   - /rolls-to-start/{playerId}: Subcollection for roll-to-start results within a game.
 *
 * Key Security Decisions:
 * - Games are publicly readable.
 * - Players can only modify their own data within a game.
 * - Game creation is implicitly allowed for authenticated users via the hostId field validation.
 * - Listing players and rolls is allowed for game participants to enable turn management and game flow.
 *
 * Denormalization for Authorization:
 * - The `Game` document stores the `hostId` which is used to authorize administrative actions on the game.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Rules for the /games/{gameId} collection.
     * @path /games/{gameId}
     * @allow get, list: Any authenticated user can read game data.
     * @allow create: Any authenticated user can create a game. The 'hostId' field must match the user's UID.
     * @allow update, delete: Only the host of the game can update or delete the game.
     * @principle Enforces game ownership for writes; allows public reads.
     */
    match /games/{gameId} {
      allow get, list: if true; // Public read access for games

      allow create: if isSignedIn() && request.resource.data.hostId == request.auth.uid;
      allow update: if isSignedIn() && isExistingOwner(resource.data.hostId);
      allow delete: if isSignedIn() && isExistingOwner(resource.data.hostId);

      /**
       * @description Rules for the /games/{gameId}/players/{playerId} subcollection.
       * @path /games/{gameId}/players/{playerId}
       * @allow get, list: Any authenticated user can read player data within a game.
       * @allow create: Only the user with the matching playerId can create their player document.
       * @allow update, delete: Only the user with the matching playerId can update or delete their player document.
       * @principle Enforces player ownership for writes within a game; allows public reads within a game.
       */
      match /games/{gameId}/players/{playerId} {
        allow get, list: if true; // Listing players is fine for game participants

        allow create: if isSignedIn() && request.auth.uid == playerId && request.resource.data.userId == playerId;
        allow update: if isSignedIn() && isExistingOwner(playerId) && request.resource.data.userId == resource.data.userId;
        allow delete: if isSignedIn() && isExistingOwner(playerId) && resource.data.userId == playerId;
      }

      /**
       * @description Rules for the /games/{gameId}/rolls-to-start/{playerId} subcollection.
       * @path /games/{gameId}/rolls-to-start/{playerId}
       * @allow get, list: Any authenticated user can read roll-to-start data within a game.
       * @allow create: Only the user with the matching playerId can create their roll-to-start document.
       * @allow update, delete: Only the user with the matching playerId can update or delete their roll-to-start document.
       * @principle Enforces player ownership for writes within a game; allows public reads within a game.
       */
      match /games/{gameId}/rolls-to-start/{playerId} {
        allow get, list: if true; // Listing rolls is fine for game participants

        allow create: if isSignedIn() && request.auth.uid == playerId;
        allow update: if isSignedIn() && isExistingOwner(playerId);
        allow delete: if isSignedIn() && isExistingOwner(playerId);
      }
    }

    /**
     * Helper functions
     */

    // Checks if the user is signed in.
    function isSignedIn() {
      return request.auth != null;
    }

    // Checks if the user is the owner of the resource, assuming the resource has an 'ownerId' field.
    function isOwner(ownerId) {
      return isSignedIn() && request.auth.uid == ownerId;
    }

    // Checks if the user is the owner of an existing resource, preventing operations on non-existent documents.
    function isExistingOwner(ownerId) {
      return isOwner(ownerId) && resource != null;
    }
  }
}