rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    // Utilizadores: Cada utilizador pode ler/escrever o seu próprio perfil.
    // Qualquer pessoa autenticada pode ler o perfil de outra pessoa (para ver níveis, etc.).
    match /users/{userId} {
      allow get: if isSignedIn();
      allow update, delete: if request.auth.uid == userId;
      allow create: if isSignedIn() && request.auth.uid == userId && request.resource.data.uid == userId;
    }

    // Jogos:
    match /games/{gameId} {
      // Qualquer utilizador autenticado pode listar os jogos para se juntar.
      allow list: if isSignedIn();
      
      // Um utilizador pode ler os dados de um jogo se ele for um jogador na partida OU se o jogo estiver à espera.
      allow get: if isSignedIn() && (isPlayerInGame(gameId) || resource.data.status == 'waiting');

      // Criação: Qualquer utilizador autenticado pode criar um jogo, desde que se defina como anfitrião.
      allow create: if isSignedIn() && request.resource.data.hostId == request.auth.uid;

      // Atualização: Permitida se for o jogador do turno, se for o anfitrião a gerir o estado, 
      // se um jogador estiver a entrar, ou se um leilão estiver ativo.
      allow update: if isSignedIn() && (
          isCurrentPlayer(gameId) || 
          isAuctionInProgress(resource) ||
          (isHost(gameId) && isManagingGame(request, resource)) ||
          isJoiningWaitingGame(request, resource)
      );

      // Eliminar: Apenas o anfitrião pode eliminar um jogo que ainda está em espera.
      allow delete: if isSignedIn() && isHost(gameId) && resource.data.status == 'waiting';

      // Subcoleção de Jogadores
      match /players/{playerId} {
        // Leitura: Um jogador pode ler os dados de qualquer jogador na partida, OU pode ler os seus próprios dados (essencial para entrar no jogo).
        allow get: if isSignedIn() && (isPlayerInGame(gameId) || request.auth.uid == playerId);

        // Listar: Só os jogadores da partida podem ver a lista de todos os jogadores, OU qualquer um pode ver a lista se o jogo estiver à espera.
        allow list: if isSignedIn() && (isPlayerInGame(gameId) || get(/databases/$(database)/documents/games/$(gameId)).data.status == 'waiting');
        
        // Criação: Um utilizador pode criar o seu próprio documento de jogador, desde que se adicione ao jogo correspondente.
        allow create: if isSignedIn() && request.auth.uid == playerId && request.resource.data.userId == playerId;
        
        // Atualização: Um jogador pode atualizar o seu próprio documento, ou o jogador do turno pode atualizar o documento de outro para pagar aluguer.
        allow update: if isSignedIn() && (
          request.auth.uid == playerId ||
          (isCurrentPlayer(gameId) && isPayingRent(request, resource))
        );
        
        // Eliminar: Um jogador pode ser eliminado (ex: falência). A lógica é gerida por transações.
        allow delete: if isSignedIn(); 
      }
       // Subcoleção de Logs
      match /logs/{logId} {
        // Leitura: Qualquer jogador na partida pode ler os logs.
        allow get, list: if isSignedIn() && isPlayerInGame(gameId);
        // Escrita: O jogador do turno pode criar uma entrada no log.
        allow create: if isSignedIn() && isCurrentPlayer(gameId);
      }
    }

    function isSignedIn() {
      return request.auth != null;
    }
    
    function isHost(gameId) {
      return get(/databases/$(database)/documents/games/$(gameId)).data.hostId == request.auth.uid;
    }
    
    function isCurrentPlayer(gameId) {
      return get(/databases/$(database)/documents/games/$(gameId)).data.currentPlayerId == request.auth.uid;
    }

    function isPlayerInGame(gameId) {
        return request.auth.uid in get(/databases/$(database)/documents/games/$(gameId)).data.playerOrder;
    }
    
    function isManagingGame(req, res) {
      let isStarting = res.data.status == 'waiting' && req.resource.data.status == 'active';
      let isFinishing = req.resource.data.status == 'finished';
      return isStarting || isFinishing;
    }

    function isJoiningWaitingGame(req, res) {
      let isWaiting = res.data.status == 'waiting';
      // Garante que o jogador está apenas a adicionar-se a si mesmo e não a outros ou a remover jogadores.
      let isAddingSelf = req.resource.data.playerOrder.size() == res.data.playerOrder.size() + 1 && req.auth.uid in req.resource.data.playerOrder;
      return isWaiting && isAddingSelf;
    }
    
    function isAuctionInProgress(res) {
      // Permite atualizações se um leilão estava ativo no documento existente.
      // Cobre lances e a finalização do leilão (que apaga o campo 'auction').
      return 'auction' in res.data && res.data.auction.status == 'active';
    }
    
    function isPayingRent(req, res) {
      // Permite que o jogador atual atualize o saldo de outro jogador (o proprietário)
      // Apenas se a ÚNICA alteração for um INCREMENTO no dinheiro.
      let onlyMoneyChanged = req.resource.data.diff(res.data).affectedKeys().hasOnly(['money']);
      let moneyIncreased = req.resource.data.money > res.data.money;
      return onlyMoneyChanged && moneyIncreased;
    }
  }
}
